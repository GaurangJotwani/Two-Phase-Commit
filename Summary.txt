Executive Summary

Assignment Overview:
The purpose of this assignment was to develop a distributed key-value storage system using Java Remote Method Invocation (RMI). The assignment aimed to demonstrate knowledge and skills in implementing Java RMI communication, managing remote objects, and handling concurrency using multithreading.
The scope of the assignment included creating a server-side program (MyServer) and a client-side program (MyClient) that interacted with the server to perform operations such as putting, getting, and deleting key-value pairs on a Remote Object.
In this assignment, remote objects played a crucial role as the underlying data structure, acting as a distributed hashmap that allowed clients to remotely store, retrieve, and delete key-value pairs on the server-side.
The RMI registry played a vital role as a centralized registry service. It acted as a lookup service for clients to locate and bind to the remote objects implemented on the server side. The server registered the remote object implementation with the RMI registry, associating it with a unique name or URL. This allowed clients to easily access and invoke remote methods on the registered objects by looking them up in the RMI registry based on their names or URLs.
Additionally, compared to the previous assignment where we implemented a distributed system using sockets, this assignment utilizing RMI proved to be a significant step forward. RMI abstracted away many of the low-level networking intricacies, simplifying the development process and allowing us to focus more on the core functionality of the distributed key-value storage system.
This abstraction provided a higher level of convenience and ease in remote method invocations, object serialization, and network communication, enabling a smoother and more efficient implementation of the distributed system.


Technical Impression:
During the completion of this assignment, I gained valuable insights into building a distributed key-value storage system using Java RMI. The assignment provided a comprehensive hands-on experience with RMI and allowed me to explore its advantages over socket-based communication.
One of the notable aspects of working with RMI was the seamless integration of remote method invocations into the system. RMI provided a natural and intuitive way to define and implement remote interfaces, allowing clients to invoke methods on remote objects as if they were local. This abstraction greatly simplified the communication between the client and server, eliminating the need for low-level socket programming and manual message parsing.
Another advantage of RMI was its built-in support for object serialization. With RMI, I could easily pass complex data structures between the client and server without worrying about the details of object serialization and deserialization. RMI took care of the serialization process transparently, making it effortless to transfer objects across the network.
Furthermore, RMI facilitated the management of distributed objects by providing automatic object activation and deactivation. Remote objects were created and activated on demand, optimizing resource utilization and improving system performance. RMI's support for object lifecycle management allowed me to focus on the business logic of the key-value storage system without having to manually manage object instantiation and destruction.

While working on the assignment, I encountered various challenges, such as handling exceptions related to RMI communication, managing timeouts, and ensuring proper error handling. These challenges required careful consideration and implementation of appropriate error handling mechanisms to provide meaningful feedback to users.
Overall, this assignment provided a practical opportunity to explore distributed systems concepts and enhance my Java RMI programming skills. It deepened my understanding of RMI, concurrency, and error handling in Java and in general distributed applications.
Moving forward, I believe there is room for improvement in optimizing the concurrency management (Thread Queues, Concurrent HashMaps etc) and refining the error handling to handle a wider range of exceptional scenarios.
In conclusion, this assignment provided a valuable learning experience in implementing a distributed key-value storage system using RMI. It fostered a deeper understanding of distributed systems concepts, concurrency control, and error handling, paving the way for further growth and exploration in this area.